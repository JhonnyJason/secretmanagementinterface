[![hackmd-github-sync-badge](https://hackmd.io/EtJSEnxjTVOOvRJdWGJlYw/badge)](https://hackmd.io/EtJSEnxjTVOOvRJdWGJlYw)
###### tags: `documentation` `sci`

# [secretmanagementinterface](https://github.com/JhonnyJason/secretmanagementinterface) v0.3

For further reference what the Secret Management is all about [read this](https://hackmd.io/PZjpRfzPSBCqS-8K54x2jA).

## Basic

### /getNodeId
Returns the `serverNodeId` of the Secret Manager service.

Requires an `authCode` to actually do something.

For general public requests we use the `authCode` of `deadbeefcafebabedeadbeefcafebabedeadbeefcafebabedeadbeefcafebabe`.
This is the default on any new Instance - it is recommended to switch the publicly known `authCode` frequently in production.

#### request
```json
{
    "authCode": "deadbeefcafebabedeadbeefcafebabedeadbeefcafebabedeadbeefcafebabe"
}
```

#### response
```json
{
    "serverNodeId": "...",
    "timestamp": "...",
    "signature": "..."
}
```

### /createAuthCode
This request creates an `authCode` for a certain action.

The `authCode` will be shared to the requestor.
Therefore we need to accept secrets from the SecretManager first.

Actions that require authCodes:
- `getNodeId`
- `setRequestableServer`
- `deleteRequestableServer`
- `openSecretSpace`


#### request
```json
{
    "action": "",
    "publicKey": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "authCode": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```


## Secret Spaces

### /openSecretSpace
If there is no `secretSpace` for this `nodeId` it creates an new `SecretSpace` object.
If there is a `closureDate` defined it will be closed(removed) at the specified date.

If we have a `closureDate` defined and a `secretSpace` already exists for this `nodeId` we will reply with an error.

We must have a valid `authCode`. This way we could limit the creation of `secretSpaces` to people we trust.

- `authCode` is to be generated by a user who already has access to the server via `/createAuthCode` specifying the `createSecretSpace` option (32byte as hex encoded string)
- `publicKey` or `nodeId` will be the id of the secretSpace - only a person proofing ownership of the right `privateKey` has access to modify, delete and read the `secretSpace` (32byte as hex encoded string)
- `closureDate` defines the exact time the secretSpace will automatically be deleted. May be `null` (=never be deleted) or `+4hours` (=will be deleted in 4 hours) or `+4days` (=will be deleted in 4 days) or `+4month` (=will be deleted in 4 month) or `+4years` (=will be deleted in 4 years) or a valid Unix Timestamp of an exact date to close the space.

#### request
```json
{
    "authCode": "",
    "publicKey": "",
    "closureDate": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}
```

### /getSecretSpace
Returns the encrypted version of the whole `secretSpace`.

#### request
```json
{
    "publicKey": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "referencePoint": "...",
    "encryptedContent": "..."
}
```

### /deleteSecretSpace
This will remove the `secretSpace` and all it's `subSpaces` effectivly deleting the according `nodeId` from the server.

#### request
```json
{
    "publicKey": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}
```
## Secrets

### /setSecret
Encryptes the given `secret` and stores it at `secretId` within the owners' `secretSpace`.

It still is recommended to also encrypt the secret beforen sending it. (As we should not completely trust SSL using CAs.)

#### request
```json
{
    "publicKey": "",
    "secretId": "",
    "secret": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}
```

### /getSecret
Returns the encrypted secret of the given `secretId`.

#### request
```json
{
    "publicKey": "",
    "secretId": "",
    "timestamp": "",
    "signature": "",
    "nonce", ""
}
```
#### response
```json
{
    "referencePoint": "...",
    "encryptedContent": "..."
}
```

### /deleteSecret
Deletes the given `secretId` from the `secretSpace`.

#### request
```json
{
    "publicKey": "",
    "secretId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}
```

## Sub Spaces

### /openSubSpace

If it does not exist it will create a new `subSpace` which goes by the key `fromId` within our `subSpaces`.
Now the `fromId` may write secrets into this `subSpace`.

Also the `subSpace` may be temporary. Therefore we should specify a `closureDate` as not `null`.

#### request
```json
{
    "publicKey": "",
    "fromId": "",
    "closureDate": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}
```


### /getSubSpace
Returns the encrypted version of the specified `subSpace`.

#### request
```json
{
    "publicKey": "",
    "fromId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "referencePoint": "...",
    "encryptedContent": "..."
}
```

### /deleteSubSpace
This will delete the object which goes by the key `fromId` within our `subSpaces`.
All shared secrets in there are lost. And the `fromId` could not share any secrets to us.

#### request
```json
{
    "publicKey": "",
    "fromId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}

```
## Shared Secrets

### /shareSecretTo
This will write the secret into the `subSpace` of the `shareToId` if it exists.

We also may specify `oneTimeSecret = true`. This means that the `shareToId` picks the secret up once - then it would be automatically deleted.

#### request
```json
{
    "publicKey": "",
    "shareToId": "",
    "secretId": "",
    "secret": "",
    "oneTimeSecret": false,
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}
```

### /getSecretFrom
Returns the encrypted secret shared to us by `fromId` having the id `secretId`.

#### request
```json
{
    "publicKey": "",
    "fromId": "",
    "secretId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "referencePoint": "...",
    "encryptedContent": "..."
}
```

### /deleteSharedSecret
This will delete the specified `secretId` if it exists in the available `subSpace` of the `sharedToId`.

#### request
```json
{
    "publicKey": "",
    "sharedToId": "",
    "secretId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}

```

## Notifications

### /addNotificationHook
This creates a hook to notify a `requestableServer` of some action.
You may add multiple notificationHooks on the same target.

We have type `log` which uses every action on the `targetId` to send a `logNotification`.
Then we have the types `event onGet`, `event onSet` and `event onDelete` which would only send the specific action as an `eventNotification`. 

The `targetId` is either `this`, `secrets.mySpecificSecretId`, `subSpaces.deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef` or
`subSpaces.deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef.secretIdSharedToMe`.

Last but not least important is the `notifyURL` where the specific notification is being sent to.

*Note: We will not wait for the server to respond and we will not parse the response.*

#### request
```json
{
    "publicKey": "",
    "type": "",
    "targetId": "",
    "notifyURL": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```

#### response
```json
{
    "ok": true
}

```

### /getNotificationHooks
This retrieves the all `notificationHooks` of the specified `targetId`. 

This may be used to investigate `notificationHooks` - check the list what has been added and if any one is not working.
Therefore the optional`error` member indicates the error.

#### request
```json
{
    "publicKey": "",
    "targetId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```

#### response
```json
{
    "notificationHooks": [
        {
            "id": "",
            "type": "",
            "url": "",
            "error": ""
        },
        ...
    ]    
}

```

### /deleteNotificationHook
The notification hook is identified by it's `id` specified here as `notificationHookId`.

#### request
```json
{
    "publicKey": "",
    "notificationHookId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```

#### response
```json
{
    "ok": true
}

```

## Requestable Servers
*Note: the API exists however it must be reasoned more about how this feature will be used exactly and if it is necessary even.*

### /setRequestableServer
#### request
```json
{
    "authCode": "",
    "serverURL": "",
    "serverNodeId": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "ok": true
}

```

### /getRequestableServer
#### request
```json
{
    "serverURL": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```
#### response
```json
{
    "serverURL": ""
    "serverNodeId": ""
}

```

### /deleteRequestableServer
#### request
```json
{
    "authCode": "",
    "serverURL": "",
    "timestamp": "",
    "signature": "",
    "nonce": ""
}
```

#### response
```json
{
    "ok": true
}

```